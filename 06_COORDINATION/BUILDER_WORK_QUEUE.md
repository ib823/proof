# BUILDER WORK QUEUE

**Generated by: BREAKER**
**Mode: ULTRA KIASU | FUCKING PARANOID | ZERO TRUST**
**Last Updated: 2026-01-15**

---

## PRIORITY: CRITICAL (FIX IMMEDIATELY)

### WORK-001: Fix Value Definition or Canonical Forms
**Source:** BREAKER P-001, P-003
**Files:** `Syntax.v`, `Progress.v`
**Description:**
The value predicate includes wrapped forms (VRequire, VGrant, VClassify, VProve, VRef) that break canonical form lemmas.

**Options:**
1. **Remove wrapper values:** Make ERequire, EGrant, etc. NOT values. They should always reduce.
2. **Fix canonical forms:** Change canonical_bool to account for all value wrappers.
3. **Add unwrapping lemmas:** Prove that wrapped values can be unwrapped to canonical forms.

**Recommendation:** Option 1 - These wrappers should step, not be values.

---

### WORK-002: Complete Progress Theorem
**Source:** BREAKER P-002
**File:** `Progress.v`
**Description:**
10 cases admitted. Each requires operational semantics to be properly defined first.

**Blocked by:** WORK-005 (reference semantics), WORK-006 (effect semantics)

---

### WORK-003: Fix Reference Semantics
**Source:** BREAKER S-001, S-002
**File:** `Semantics.v`
**Description:**
References don't actually use the store. Need complete redesign:

1. Add `ELoc : nat -> expr` for runtime locations
2. Add `VLoc : forall n, value (ELoc n)`
3. Change ST_Ref to allocate in store and return location
4. Change ST_DerefLoc to read from store
5. Change ST_AssignLoc to write to store

**Template:**
```coq
| ELoc : nat -> expr  (* Runtime heap location *)

| VLoc : forall n, value (ELoc n)

| ST_RefValue : forall v l st ctx,
    value v ->
    let fresh := length st in
    (ERef v l, st, ctx) --> (ELoc fresh, st ++ [(fresh, v)], ctx)

| ST_DerefLoc : forall n st ctx v,
    store_lookup n st = Some v ->
    (EDeref (ELoc n), st, ctx) --> (v, st, ctx)

| ST_AssignLoc : forall n v st ctx,
    value v ->
    (EAssign (ELoc n) v, st, ctx) --> (EUnit, store_update n v st, ctx)
```

---

### WORK-004: Fix Declassification Security
**Source:** BREAKER S-004, T-003
**Files:** `Semantics.v`, `Typing.v`
**Description:**
The proof type is meaningless - any value can serve as a proof.

**Options:**
1. **Intrinsic proofs:** Change TProof to carry actual evidence (e.g., TProof P where P is a proposition)
2. **Authority-based:** Proofs can only come from trusted sources (new EAuthority construct)
3. **Remove declassification:** If you can't do it securely, don't do it

**Minimum fix:** The semantic rule should check that the proof is actually related to the secret being declassified, not just any random value.

---

### WORK-005: Complete preservation_helper
**Source:** BREAKER R-001, R-002
**File:** `Preservation.v`
**Description:**
Missing cases in both `value_has_pure_effect` and `preservation_helper`.

Add cases for:
- VRef, VClassify, VProve, VRequire, VGrant in value_has_pure_effect
- All ST_* rules for effects, refs, security in preservation_helper

**Blocked by:** WORK-003 (reference semantics must be fixed first)

---

### WORK-006: Implement Effect Runtime Checking
**Source:** BREAKER S-003
**File:** `Semantics.v`
**Description:**
Effect context is passed but never checked. Add:

```coq
| ST_PerformAllowed : forall eff v st ctx,
    value v ->
    has_effect eff ctx ->  (* ADD THIS CHECK *)
    (EPerform eff v, st, ctx) --> (v, st, ctx)

| ST_GrantPush : forall eff v st ctx,
    value v ->
    (EGrant eff v, st, ctx) --> (v, st, eff :: ctx)  (* Push to context *)

| ST_RequireCheck : forall eff v st ctx,
    value v ->
    has_effect eff ctx ->  (* Must have capability *)
    (ERequire eff v, st, ctx) --> (v, st, ctx)
```

---

## PRIORITY: HIGH

### WORK-007: Add Missing Canonical Forms
**Source:** BREAKER P-004
**File:** `Progress.v`
**Description:**
Add canonical form lemmas for: TUnit, TInt, TString, TBytes, TRef, TSecret, TProof, TCapability

---

### WORK-008: Fix Store Typing
**Source:** BREAKER P-005, T-004
**Files:** `Typing.v`, `Progress.v`, `Preservation.v`
**Description:**
Store typing Σ is decorative. Either:
1. Remove it (if not needed)
2. Properly integrate it with reference typing rules

---

### WORK-009: Complete Step Determinism
**Source:** BREAKER S-005
**File:** `Semantics.v`
**Description:**
`step_deterministic` proof is incomplete. Add cases for all step rules.

---

### WORK-010: Effect Subsumption Rule
**Source:** BREAKER T-002
**File:** `Typing.v`
**Description:**
Consider adding:
```coq
| T_EffectSub : forall Γ Σ Δ e T ε1 ε2,
    has_type Γ Σ Δ e T ε1 ->
    effect_leq ε1 ε2 = true ->
    has_type Γ Σ Δ e T ε2.
```

---

## PRIORITY: MEDIUM

### WORK-011: Document Grant Semantics
**Source:** BREAKER T-001
**File:** `Typing.v`
**Description:**
Clarify whether T_Grant effect behavior is intentional. If so, document. If not, fix.

---

## DEPENDENCY GRAPH

```
WORK-001 (Values) ─────────────────┐
                                   ├──> WORK-002 (Progress)
WORK-003 (References) ─────────────┤
                                   │
WORK-006 (Effects) ────────────────┤
                                   │
WORK-004 (Declassification) ───────┘

WORK-003 (References) ──> WORK-005 (Preservation)

WORK-007 (Canonical Forms) ──> WORK-002 (Progress)

WORK-008 (Store Typing) ──> WORK-003, WORK-005
```

---

## STATUS

| ID | Priority | Status | Assignee | Notes |
|----|----------|--------|----------|-------|
| WORK-001 | CRITICAL | OPEN | BUILDER | Blocks WORK-002 |
| WORK-002 | CRITICAL | BLOCKED | - | Needs WORK-001,003,006 |
| WORK-003 | CRITICAL | OPEN | BUILDER | Major redesign |
| WORK-004 | CRITICAL | OPEN | BUILDER | Security critical |
| WORK-005 | CRITICAL | BLOCKED | - | Needs WORK-003 |
| WORK-006 | CRITICAL | OPEN | BUILDER | Runtime effects |
| WORK-007 | HIGH | OPEN | BUILDER | |
| WORK-008 | HIGH | OPEN | BUILDER | |
| WORK-009 | HIGH | OPEN | BUILDER | |
| WORK-010 | HIGH | OPEN | BUILDER | |
| WORK-011 | MEDIUM | OPEN | BUILDER | Documentation |

---

*BREAKER identifies. BUILDER fixes. Trust nothing.*
