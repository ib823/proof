# BUILDER WORK QUEUE

**Generated by: BREAKER**
**Mode: ULTRA KIASU | FUCKING PARANOID | ZERO TRUST**
**Last Updated: 2026-01-15**

---

## PRIORITY: CRITICAL (FIX IMMEDIATELY)

### WORK-001: Fix Value Definition or Canonical Forms
**Source:** BREAKER P-001, P-003
**Files:** `Syntax.v`, `Progress.v`
**Description:**
The value predicate includes wrapped forms (VRequire, VGrant, VClassify, VProve, VRef) that break canonical form lemmas.

**Options:**
1. **Remove wrapper values:** Make ERequire, EGrant, etc. NOT values. They should always reduce.
2. **Fix canonical forms:** Change canonical_bool to account for all value wrappers.
3. **Add unwrapping lemmas:** Prove that wrapped values can be unwrapped to canonical forms.

**Recommendation:** Option 1 - These wrappers should step, not be values.

---

### WORK-002: Complete Progress Theorem
**Source:** BREAKER P-002
**File:** `Progress.v`
**Description:**
10 cases admitted. Each requires operational semantics to be properly defined first.

**Blocked by:** WORK-005 (reference semantics), WORK-006 (effect semantics)

---

### WORK-003: Fix Reference Semantics
**Source:** BREAKER S-001, S-002
**File:** `Semantics.v`
**Description:**
References don't actually use the store. Need complete redesign:

1. Add `ELoc : nat -> expr` for runtime locations
2. Add `VLoc : forall n, value (ELoc n)`
3. Change ST_Ref to allocate in store and return location
4. Change ST_DerefLoc to read from store
5. Change ST_AssignLoc to write to store

**Template:**
```coq
| ELoc : nat -> expr  (* Runtime heap location *)

| VLoc : forall n, value (ELoc n)

| ST_RefValue : forall v l st ctx,
    value v ->
    let fresh := length st in
    (ERef v l, st, ctx) --> (ELoc fresh, st ++ [(fresh, v)], ctx)

| ST_DerefLoc : forall n st ctx v,
    store_lookup n st = Some v ->
    (EDeref (ELoc n), st, ctx) --> (v, st, ctx)

| ST_AssignLoc : forall n v st ctx,
    value v ->
    (EAssign (ELoc n) v, st, ctx) --> (EUnit, store_update n v st, ctx)
```

---

### WORK-004: Fix Declassification Security
**Source:** BREAKER S-004, T-003
**Files:** `Semantics.v`, `Typing.v`
**Description:**
The proof type is meaningless - any value can serve as a proof.

**Options:**
1. **Intrinsic proofs:** Change TProof to carry actual evidence (e.g., TProof P where P is a proposition)
2. **Authority-based:** Proofs can only come from trusted sources (new EAuthority construct)
3. **Remove declassification:** If you can't do it securely, don't do it

**Minimum fix:** The semantic rule should check that the proof is actually related to the secret being declassified, not just any random value.

---

### WORK-005: Complete preservation_helper
**Source:** BREAKER R-001, R-002
**File:** `Preservation.v`
**Description:**
Missing cases in both `value_has_pure_effect` and `preservation_helper`.

Add cases for:
- VRef, VClassify, VProve, VRequire, VGrant in value_has_pure_effect
- All ST_* rules for effects, refs, security in preservation_helper

**Blocked by:** WORK-003 (reference semantics must be fixed first)

---

### WORK-006: Implement Effect Runtime Checking
**Source:** BREAKER S-003
**File:** `Semantics.v`
**Description:**
Effect context is passed but never checked. Add:

```coq
| ST_PerformAllowed : forall eff v st ctx,
    value v ->
    has_effect eff ctx ->  (* ADD THIS CHECK *)
    (EPerform eff v, st, ctx) --> (v, st, ctx)

| ST_GrantPush : forall eff v st ctx,
    value v ->
    (EGrant eff v, st, ctx) --> (v, st, eff :: ctx)  (* Push to context *)

| ST_RequireCheck : forall eff v st ctx,
    value v ->
    has_effect eff ctx ->  (* Must have capability *)
    (ERequire eff v, st, ctx) --> (v, st, ctx)
```

---

## PRIORITY: HIGH

### WORK-007: Add Missing Canonical Forms
**Source:** BREAKER P-004
**File:** `Progress.v`
**Description:**
Add canonical form lemmas for: TUnit, TInt, TString, TBytes, TRef, TSecret, TProof, TCapability

---

### WORK-008: Fix Store Typing
**Source:** BREAKER P-005, T-004
**Files:** `Typing.v`, `Progress.v`, `Preservation.v`
**Description:**
Store typing Σ is decorative. Either:
1. Remove it (if not needed)
2. Properly integrate it with reference typing rules

---

### WORK-009: Complete Step Determinism
**Source:** BREAKER S-005
**File:** `Semantics.v`
**Description:**
`step_deterministic` proof is incomplete. Add cases for all step rules.

---

### WORK-010: Effect Subsumption Rule
**Source:** BREAKER T-002
**File:** `Typing.v`
**Description:**
Consider adding:
```coq
| T_EffectSub : forall Γ Σ Δ e T ε1 ε2,
    has_type Γ Σ Δ e T ε1 ->
    effect_leq ε1 ε2 = true ->
    has_type Γ Σ Δ e T ε2.
```

---

### WORK-012: Implement Actual Effect Safety
**Source:** BREAKER E-001
**File:** `EffectSystem.v`
**Description:**
`effect_safety` theorem proves `True`. Must prove actual effect containment.

**Required:**
```coq
(* Define effect trace *)
Inductive produces_effect : expr -> store -> effect_ctx -> effect -> Prop := ...

(* Actual theorem *)
Theorem effect_safety_real : forall e T eff,
  has_type_full nil nil Public e T eff ->
  forall st ctx eff',
    produces_effect e st ctx eff' ->
    effect_leq eff' eff.
```

---

### WORK-013: Implement Actual Gate Enforcement
**Source:** BREAKER G-001, G-002
**File:** `EffectGate.v`
**Description:**
`is_gate` is defined as `True`. `gate_enforcement` proves `True`. Need real definitions.

**Required:**
```coq
(* Real gate definition *)
Definition is_gate (eff : effect) (e_gate : expr) : Prop :=
  forall e st ctx e' st' ctx',
    (EHandle e_gate e) with effect eff ->
    ~ produces_effect_unhandled eff e' st' ctx'.

(* Real enforcement *)
Theorem gate_enforcement_real : forall e T eff_allowed,
  has_type_full nil nil Public e T eff_allowed ->
  forall st ctx eff_used,
    produces_effect e st ctx eff_used ->
    effect_level eff_used <= effect_level eff_allowed.
```

---

### WORK-014: Fix Type Specification Inconsistency
**Source:** BREAKER E-002, E-003
**Files:** `Typing.v`, `EffectSystem.v`
**Description:**
T_Perform and T_Declassify have DIFFERENT definitions in the two files:
- T_Perform: Typing.v gives type T, EffectSystem.v gives TUnit
- T_Declassify: Typing.v needs TProof(TSecret T), EffectSystem.v needs TProof T

**Fix:** Reconcile specifications. Choose ONE authoritative definition.

---

### WORK-015: Implement SecurityProperties
**Source:** BREAKER SP-001
**File:** `SecurityProperties.v`
**Description:**
File is empty. Must define security properties:
- Confidentiality
- Integrity
- Availability guarantees
- Effect isolation

---

### WORK-016: Extend NonInterference to Full Language
**Source:** BREAKER NI-002
**File:** `NonInterference.v`
**Description:**
`logical_relation` only covers `has_type` (pure functional fragment). Must extend to:
- Effects (T_Perform, T_Handle)
- References (T_Ref, T_Deref, T_Assign)
- Security (T_Classify, T_Declassify, T_Prove)
- Capabilities (T_Require, T_Grant)

---

### WORK-017: Add Store Relation for NonInterference
**Source:** BREAKER NI-003
**File:** `NonInterference.v`
**Description:**
`val_rel` for functions allows arbitrary different stores. Need store relation:
```coq
Definition store_rel (l : security_level) (st1 st2 : store) : Prop :=
  forall loc v1 v2 T l',
    store_lookup loc st1 = Some v1 ->
    store_lookup loc st2 = Some v2 ->
    sec_leq l' l ->  (* Only relate low-security locations *)
    val_rel T v1 v2.
```

---

### WORK-018: Implement Composition Properties
**Source:** BREAKER C-001
**File:** `Composition.v`
**Description:**
File is empty. Must prove compositionality:
- If e1 safe and e2 safe, then (e1; e2) safe
- Security composes across module boundaries
- Effect composition is monotonic

---

## PRIORITY: MEDIUM

### WORK-011: Document Grant Semantics
**Source:** BREAKER T-001
**File:** `Typing.v`
**Description:**
Clarify whether T_Grant effect behavior is intentional. If so, document. If not, fix.

---

## DEPENDENCY GRAPH

```
WORK-001 (Values) ─────────────────┐
                                   ├──> WORK-002 (Progress)
WORK-003 (References) ─────────────┤
                                   │
WORK-006 (Effects) ────────────────┤
                                   │
WORK-004 (Declassification) ───────┘

WORK-003 (References) ──> WORK-005 (Preservation)

WORK-007 (Canonical Forms) ──> WORK-002 (Progress)

WORK-008 (Store Typing) ──> WORK-003, WORK-005
```

---

## STATUS

| ID | Priority | Status | Assignee | Notes |
|----|----------|--------|----------|-------|
| WORK-001 | CRITICAL | OPEN | BUILDER | Blocks WORK-002 |
| WORK-002 | CRITICAL | BLOCKED | - | Needs WORK-001,003,006 |
| WORK-003 | CRITICAL | OPEN | BUILDER | Major redesign |
| WORK-004 | CRITICAL | OPEN | BUILDER | Security critical |
| WORK-005 | CRITICAL | BLOCKED | - | Needs WORK-003 |
| WORK-006 | CRITICAL | OPEN | BUILDER | Runtime effects |
| WORK-007 | HIGH | OPEN | BUILDER | Canonical forms |
| WORK-008 | HIGH | OPEN | BUILDER | Store typing |
| WORK-009 | HIGH | OPEN | BUILDER | Determinism |
| WORK-010 | HIGH | OPEN | BUILDER | Effect subsumption |
| WORK-011 | MEDIUM | OPEN | BUILDER | Documentation |
| WORK-012 | CRITICAL | OPEN | BUILDER | Effect safety stub |
| WORK-013 | CRITICAL | OPEN | BUILDER | Gate enforcement stub |
| WORK-014 | CRITICAL | OPEN | BUILDER | Spec inconsistency |
| WORK-015 | CRITICAL | OPEN | BUILDER | Empty file |
| WORK-016 | CRITICAL | OPEN | BUILDER | NI incomplete |
| WORK-017 | HIGH | OPEN | BUILDER | Store relation |
| WORK-018 | CRITICAL | OPEN | BUILDER | Empty file |

**Total: 18 work items (11 CRITICAL, 5 HIGH, 2 MEDIUM)**

---

*BREAKER identifies. BUILDER fixes. Trust nothing.*
*Last updated: 2026-01-15 - Cycle 2*
